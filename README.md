# javascript-programming-language

Javascript programming language guidelines/notebook

**Javascript core basic**<br>

  * [Variables and Data Types](https://github.com/kaleeswariP/javascript-guide/edit/master/README.md#variables-and-data-types)
      * [Variables](https://github.com/kaleeswariP/javascript-guide?tab=readme-ov-file#variables)
      * [Data types](https://github.com/kaleeswariP/javascript-guide?tab=readme-ov-file#data-types)
  * [Operators](https://github.com/kaleeswariP/javascript-guide#operators)
  * [Control Structures](https://github.com/kaleeswariP/javascript-guide/edit/master/README.md#control-structures)
      * [Conditionals](https://github.com/kaleeswariP/javascript-guide?tab=readme-ov-file#conditionals)
      * [`for ...in` loop](https://github.com/kaleeswariP/javascript-guide?tab=readme-ov-file#for-in-loop)
      * [`for ...of` loop](https://github.com/kaleeswariP/javascript-guide?tab=readme-ov-file#for-of-loop)
      * [`foreach`]()
      * [control statements - break, continue](https://github.com/kaleeswariP/javascript-guide?tab=readme-ov-file#loop-breaking-statements)
  * [Functions](https://github.com/kaleeswariP/javascript-guide#functions)
      * [Function declaration](https://github.com/kaleeswariP/javascript-guide?tab=readme-ov-file#function-declaration)
      * [Function expression](https://github.com/kaleeswariP/javascript-guide?tab=readme-ov-file#function-expression)
      * [Arrow functions](https://github.com/kaleeswariP/javascript-guide?tab=readme-ov-file#arrow-functionses6)
  * [Objects and Arrays](https://github.com/kaleeswariP/javascript-guide#objects-and-arrays)
      * [Objects]()
      * [Arrays]()
  * [Asynchronous javascripts](https://github.com/kaleeswariP/javascript-guide?tab=readme-ov-file#asynchronous-javascript)
      * [Callback](https://github.com/kaleeswariP/javascript-guide?tab=readme-ov-file#callbacks)
      * [Promise]()
      * [Async-await]() 
  * [Strings](https://github.com/kaleeswariP/javascript-guide?tab=readme-ov-file#strings)
  * [Dates Handling](https://github.com/kaleeswariP/javascript-guide?tab=readme-ov-file#dates-handling)
  * [Map and Set](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#map-and-set)
      * [Map](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#map)
      * [WeekMap](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#weekmap)
      * [Set](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#set)
      * [WeekSet](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#weekset)
  * [DOM Manipulation APIs](https://github.com/kaleeswariP/javascript-guide?tab=readme-ov-file#dates-handling)
  * [Web storage in JS](https://github.com/kaleeswariP/javascript-guide?tab=readme-ov-file#web-storage-in-js)
      * [Local storage](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#local-storage)
      * [Session storage](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#session-storage)
      * [Cookies](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#cookie)

**Working of JS Engine**<br>

* [Working of JS Engine](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#working-of-js-engine)

**Advanced Topics**<br>

* [Event Loop, Microtasks, Macrotasks](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#event-loop-microtasks-macrotasks)
* [Events: DOMContentLoaded, load, beforeunload, unload](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#events-domcontentloaded-load-beforeunload-unload)
* [Polyfilles](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#polyfills)
* [Memoization](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#memoization)
* [Generator Functions](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#generator-functions)
* [Web APIs](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#web-apis)
* [Design Patterns](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#design-patterns)


**Coding Concepts**<br>

 * [Currying](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#1-currying)
 * [Closures](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#2-closures)
    * [Factory functions](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#factory-functions)
    * [Dynamic function generation](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#dynamic-function-generation)
 * [IIFE](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#3-iife)
 * [Destructuring](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#4-destructuring)
 * [Inheritance](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#5-inheritance)
   * [Prototype inheritance](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#5-inheritance)
   * [Class inheritance](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#class-inheritance)
 * [Spread and Rest operator](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#6-spread-and-rest-operator)
 * [Callback, Promises, and Async Await](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#7-callback-promises-and-async-await)
 * [Debouncing and Throttling](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#8-debouncing-and-throttling)
 * [Event Propagation, Event Bubbling, Capturing, and Delegation](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#9-event-propagation-event-bubbling-capturing-and-delegation)
 * [setTimeout, setInterval](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#10-settimeout-setinterval)
 * [High Order Functions](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#11-high-order-functions)
     * [First order functions]()
     * [Pure functions]()
 * [Call, Apply, Bind](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#12-call-apply-bind)
 * [Hoisting and Temporal dead zone](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#13-hoisting-and-temporal-dead-zone)
 * [Call by value and call by the difference](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#14-call-by-value-and-call-by-the-difference)
 * [Execution Context](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#15-execution-context)
 * [Callstack](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#16-callstack)
 * [How asynchronous functions work inside loops](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#2-swap-the-two-variables-values-without-using-the-temporary-variable)


**Javascript coding practices/Challenges**<br>

* [What is the output of the snippet below](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#1-what-is-the-output-of-the-snippet-below)
* [Swap the two variables' values without using the temporary variable]()

**Javascript Real-time code snippets**<br>





# Javascript Core Basics
  * [Variables and Data Types](https://github.com/kaleeswariP/javascript-guide/edit/master/README.md#variables-and-data-types)
      * [Variables](https://github.com/kaleeswariP/javascript-guide?tab=readme-ov-file#variables)
      * [Data types](https://github.com/kaleeswariP/javascript-guide?tab=readme-ov-file#data-types)
  * [Operators](https://github.com/kaleeswariP/javascript-guide#operators)
  * [Control Structures](https://github.com/kaleeswariP/javascript-guide/edit/master/README.md#control-structures)
      * [Conditionals](https://github.com/kaleeswariP/javascript-guide?tab=readme-ov-file#conditionals)
      * [`for ...in` loop](https://github.com/kaleeswariP/javascript-guide?tab=readme-ov-file#for-in-loop)
      * [`for ...of` loop](https://github.com/kaleeswariP/javascript-guide?tab=readme-ov-file#for-of-loop)
      * [`foreach`]()
      * [control statements - break, continue](https://github.com/kaleeswariP/javascript-guide?tab=readme-ov-file#loop-breaking-statements)
  * [Functions](https://github.com/kaleeswariP/javascript-guide#functions)
      * [Function declaration](https://github.com/kaleeswariP/javascript-guide?tab=readme-ov-file#function-declaration)
      * [Function expression](https://github.com/kaleeswariP/javascript-guide?tab=readme-ov-file#function-expression)
      * [Arrow functions](https://github.com/kaleeswariP/javascript-guide?tab=readme-ov-file#arrow-functionses6)
  * [Objects and Arrays](https://github.com/kaleeswariP/javascript-guide#objects-and-arrays)
      * [Objects]()
      * [Arrays]()
  * [Asynchronous javascripts](https://github.com/kaleeswariP/javascript-guide?tab=readme-ov-file#asynchronous-javascript)
      * [Callback](https://github.com/kaleeswariP/javascript-guide?tab=readme-ov-file#callbacks)
      * [Promise]()
      * [Async-await]() 
  * [Strings](https://github.com/kaleeswariP/javascript-guide?tab=readme-ov-file#strings)
  * [Dates Handling](https://github.com/kaleeswariP/javascript-guide?tab=readme-ov-file#dates-handling)
  * [Map and Set]()
      * [Map]()
      * [WeekMap]()
      * [Set]()
      * [WeekSet]()
  * [DOM Manipulation APIs](https://github.com/kaleeswariP/javascript-guide?tab=readme-ov-file#dates-handling)
  * [Web storage in JS](https://github.com/kaleeswariP/javascript-guide?tab=readme-ov-file#web-storage-in-js)
      * [Local storage]()
      * [Session storage]()
      * [Cookies]()

## Variables and Data Types

## Variables: 
Containers for storing data values.
```javascript
var name = 'Alice';    // ES5
let age = 25;          // ES6
const isStudent = true; // ES6
```
Refer to Hoisting to know more about variable differences. [Hoisting](https://github.com/kaleeswariP/javascript-guide/edit/master/README.md#8-hoisting)


## Data Types: 
JavaScript supports various data types, including:

* **Primitive:** `string`, `number`, `boolean`, `null`, `undefined`, `symbol` `(ES6)`, `bigint` `(ES11)`.
* **Non-primitive:** `object`, `array`, `function`.

You can refer to call by value and call by difference to know the difference between data types.[Call by value and call by reference](https://github.com/kaleeswariP/javascript-guide/edit/master/README.md#9-call-by-value-and-call-by-difference)

## Operators

* **Arithmetic Operators:** `+`, `-`, `*`, `/`, `%`, `++`, `--`.
* **Comparison Operators:** `==`, `===`, `!=`, `!==`, `>`, `<`, `>=`, `<=`.
* **Logical Operators:** `&&`, `||`, `!`.

## Control Structures

### **Conditionals:** 
`if`, `else if`, `else`, `switch`.
```javascript
if (age > 18) {
  console.log('Adult');
} else {
  console.log('Minor');
}
```
### **Loops:**
`for`, `while`, `do...while`, `for...of` `(ES6)`, `for...in`.

#### `for ...in` loop

**Purpose:** The `for...in` loop is used to iterate over the enumerable properties of an object (including inherited properties).

**Usage:** It is commonly used to loop through the properties of an object.

**Iterates Over:** <strong>Keys (property names) of the object.</strong>

Example
```javascript
const person = { name: 'Alice', age: 25, city: 'New York' };

for (let key in person) {
  console.log(`${key}: ${person[key]}`);
}
```
#### `for ...of` loop

**Purpose:** The `for...of` loop is used to iterate over iterable objects (like arrays, strings, maps, sets, etc.).

**Usage:** It is commonly used to loop through the values of an iterable object.

**Iterates Over:**  <strong>Values of the iterable.</strong>

```javascript
const numbers = [1, 2, 3, 4, 5];

for (let number of numbers) {
  console.log(number);
}
```

**Remember strings are also iterable objects so you can use ```for ...of``` to iterate string** Refer - [String](https://github.com/kaleeswariP/javascript-guide/edit/master/README.md#strings)

Use ``for...of`` when you need to access the values of an iterable object like an array, string, Map, Set, etc.

**Inherited Properties:**

`for...in` will iterate over all enumerable properties, including those inherited through the prototype chain.

`for...of` only iterates over the values in the iterable object and does not consider inherited properties.

Example with prototype:
```javascript
function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.city = 'New York';

const person = new Person('Alice', 25);

for (let key in person) {
  console.log(`${key}: ${person[key]}`);
}

```

#### `forEach` loop



### Loop-breaking statements
loop breaking statements are used to alter the flow of loop iterations.

Two primary statements are used for this purpose: `break` and `continue`.  
#### `break` statement
The `break` statement is used to terminate the loop immediately, regardless of the iteration count or condition. 

When a `break` statement is encountered inside a loop, the loop stops executing, and the control is transferred to the statement immediately following the loop.

```javascript
for (let i = 0; i < 10; i++) {
  if (i === 5) {
    break; // Exit the loop when i equals 5
  }
  console.log(i);
}
```
#### `continue` Statement
The `continue` statement is used to skip the current iteration of the loop and move to the next iteration.

When a `continue` statement is encountered, the loop continues with the next iteration, bypassing the remaining code inside the loop for the current iteration.

```javascript
for (let i = 0; i < 10; i++) {
  if (i % 2 === 0) {
    continue; // Skip even numbers
  }
  console.log(i);
}
```
#### Nested loops
In nested loops, `break` and `continue` only affect the loop they are in. To break out of an outer loop, you can use labeled statements.

**Labeled Statements:** Allow breaking out of or continuing specific loops in nested loop structures

```javascript
outerLoop: for (let i = 0; i < 3; i++) { // labeled statement
  for (let j = 0; j < 3; j++) {
    if (i === 1 && j === 1) {
      break outerLoop; // Exit both loops
    }
    console.log(`i = ${i}, j = ${j}`);
  }
}

```

## Functions

### **Function Declaration**
A function declaration defines a named function using the `function` keyword. 

Function declarations are hoisted, which means they can be called before they are defined in the code.

**Hoisting:** Function declarations are hoisted to the top of their scope, so they can be called before they are defined. Refer - [Hoisting](https://github.com/kaleeswariP/javascript-guide/edit/master/README.md#8-hoisting)
**Named Functions:** Function declarations must have a name.
**Can be Recursive:** Named functions can call themselves recursively.

```javascript
function greet(name) {
  return 'Hello, ' + name;
}
```
### **Function Expression**
A function expression defines a function inside an expression.

Function expressions can be named or anonymous. 

They are not hoisted, so they cannot be called before they are defined.

**Not Hoisted:** Function expressions are not hoisted, so they must be defined before they are called.
**Anonymous or Named:** Function expressions can be anonymous or have a name.
**Useful for Closures:** Function expressions are commonly used in closures and IIFEs (Immediately Invoked Function Expressions). Refer to [Closures]() and [IIFEs]()

```javascript
const greet = function(name) {
  return 'Hello, ' + name;
};
```
### **Arrow functions`(ES6)`**
Arrow functions, introduced in ES6, provide a shorter syntax for writing function expressions. They have a different behavior regarding the `this` keyword compared to regular functions.

**Shorter Syntax:** Arrow functions have a concise syntax.
**Implicit Return:** If the function body consists of a single expression, it can return the value implicitly without the return keyword.
```javascript
const greet = name => `Hello, ${name}!`;
```
**No this Binding:** Arrow functions do not have their own `this` context; they inherit `this` from the enclosing lexical scope.

```javascript
const greet = (name) => 'Hello, ' + name;
```
**Cannot be Used as Constructors:** Arrow functions cannot be used with the `new` keyword to create instances.
```javascript
const Person = (name) => {
  this.name = name;
};

const alice = new Person('Alice'); // TypeError: Person is not a constructor

```
**No arguments Object:** Arrow functions do not have their own `arguments` object. They inherit arguments from the parent scope.
```javascript
function regularFunction() {
  console.log(arguments);
}

const arrowFunction = () => {
  console.log(arguments);
};

regularFunction(1, 2, 3); // [1, 2, 3]
arrowFunction(1, 2, 3);   // ReferenceError: arguments is not defined

```
![image](https://github.com/kaleeswariP/javascript-guide/assets/22699303/c5210b4d-91ff-4e3e-a54c-d0d0b54991cb)


## Objects and arrays
* **Objects:** Collections of key-value pairs.

```javascript
`const user = {
  name: 'Alice',
  age: 25,
  greet: function() {
    return 'Hello, ' + this.name;
  }
};
console.log(user.greet()); // Hello, Alice
```
Ways to Loop through objects.
![Loop through objects](https://github.com/kaleeswariP/javascript-guide/assets/22699303/b6fa943e-251a-4358-9f50-c64dd9b3a8dc)

* **Arrays:** Ordered collections of values.

```javascript
`const numbers = [1, 2, 3, 4, 5];
console.log(numbers[0]); // 1
```

## Asynchronous JavaScript
### Callbacks: 
Functions passed as arguments to other functions.

```javascript
function fetchData(callback) {
  setTimeout(() => {
    callback('Data loaded');
  }, 1000);
}
fetchData(data => console.log(data));
```
### Promises: 
Represent future values or errors.

```javascript
`const promise = new Promise((resolve, reject) => {
  setTimeout(() => resolve('Data loaded'), 1000);
});
promise.then(data => console.log(data));
```
### Async/Await (ES8): 
Syntactic sugar for working with Promises.

```javascript
async function fetchData() {
  const data = await promise;
  console.log(data);
}
fetchData();
```
Refer [Callbacks-promises-asyncs-await](https://github.com/kaleeswariP/javascript-guide/edit/master/README.md#7-callback-promises-and-async-await)

## Strings
A string is a sequence of characters used to represent text. Strings are one of the fundamental data types in JavaScript<br>

**Declaration:** Strings can be declared using single quotes (') or double quotes (").<br>

**String Methods:** JavaScript provides a variety of built-in methods to manipulate strings, such as toUpperCase(), toLowerCase(), charAt(), substring(), slice(), indexOf(), replace(), trim(), split(), etc.<br>

Image representations

![string methods js](https://github.com/kaleeswariP/javascript-guide/assets/22699303/afeb40f6-70e7-431e-88db-638b99d79e9b)


**Template Literals:** Introduced in ES6, template literals allow for more flexible string formatting and interpolation(process of inserting something into something else) using backticks `() and ${}` placeholders.<br>

Refer - [string related tasks](https://github.com/kaleeswariP/javascript-guide/edit/master/README.md#6-string-related-tasks)

## Dates Handling
Date functions are methods that allow you to work with dates and times. These functions are part of the built-in Date object in JavaScript.<br>
Refer - [Date related tasks]()

### **Creating a Date Object:**
`new Date()`: Creates a new Date object representing the current date and time.<br>

`new Date(milliseconds)`: Creates a new Date object from the number of milliseconds since January 1, 1970, 00:00:00 UTC (the Unix Epoch).<br>

`new Date(dateString)`: Creates a new Date object from a date string.<br>

`new Date(year, month, day, hours, minutes, seconds, milliseconds)`: Creates a new Date object with the specified date and time components.<br>

### **Getting Date Components:**
`getDate(), getMonth(), getFullYear()`: Get the day of the month, month (0-11), and year, respectively.<br>

`getDay()`: Get the day of the week (0-6, where 0 is Sunday).<br>

`getHours(), getMinutes(), getSeconds(), getMilliseconds()`: Get the hours, minutes, seconds, and milliseconds, respectively.<br>

### **Setting Date Components:**
`setDate(day), setMonth(month), setFullYear(year)`: Set the day of the month, month (0-11), and year, respectively.<br>

`setHours(hours), setMinutes(minutes), setSeconds(seconds), setMilliseconds(milliseconds)`: Set the hours, minutes, seconds, and milliseconds, respectively.

### **Formatting Dates:**
`toDateString(), toISOString(), toLocaleDateString(), toLocaleString(), toLocaleTimeString(), toString(), toTimeString(), toUTCString()`: These methods convert a Date object to various string representations according to different formatting rules and locales.

## Map and Set
Map and Set are two built-in objects introduced in ECMAScript 2015 (ES6) that provide additional ways to manage collections of data. 

They offer more sophisticated capabilities compared to plain objects and arrays, particularly in terms of **key-value pair** handling and ensuring uniqueness.

`WeakMap` and `WeakSet` are special types of collections in JavaScript introduced in ECMAScript 2015 (ES6).

They are similar to `Map` and `Set` but have some key differences, particularly in terms of how they handle references to objects and their garbage collection behavior.


### Map
A `Map` is an ordered collection of key-value pairs, where keys can be of any type (including objects, functions, and primitive types).

It maintains the insertion order of its elements, meaning that when you iterate over the keys, they appear in the order they were inserted.

**Basic Operations:** Creating a Map, Adding Elements, Retrieving Elements, Checking for Existence, Removing Elements, Getting the Size, and Clearing All Elements.

```javascript
const myMap = new Map();

myMap.set('a', 1);
myMap.set('b', 2);

console.log(myMap.get('a')); // 1

console.log(myMap.has('b')); // true

myMap.delete('a');

console.log(myMap.size); // 1

myMap.clear();

```

**Iteration** You can iterate over the keys, values, or entries of a `Map`.
```javascript
const myMap = new Map([
  ['a', 1],
  ['b', 2],
  ['c', 3]
]);

// Iterating over keys
for (const key of myMap.keys()) {
  console.log(key); // 'a', 'b', 'c'
}

// Iterating over values
for (const value of myMap.values()) {
  console.log(value); // 1, 2, 3
}

// Iterating over entries
for (const [key, value] of myMap.entries()) {
  console.log(key, value); // ['a', 1], ['b', 2], ['c', 3]
}
```

### WeekMap

A  `WeakMap` is a collection of key-value pairs where the keys are objects and the values can be arbitrary values. 

The key feature of a `WeakMap` is that it holds "weak" references to the keys, which means that if there are no other references to the key object, it can be garbage collected.

**Characteristics**<br>

Keys must be objects: Primitive data types `(e.g., `strings`, `numbers`)` cannot be used as keys.

No size property: `WeakMap` does not have a `size` property or any method to get the number of entries.

No iterations: You cannot iterate over the entries of a `WeakMap` (no `keys()`, `values()`, `entries()`, or `forEach()` methods).

Garbage collection: If the key object is no longer reachable from the program, it can be garbage collected, and its entry in the `WeakMap` will be removed.

**Methods**<br>

`set(key, value)`: Adds or updates an entry with the specified key and value.

`get(key)`: Returns the value associated with the specified key, or undefined if the key is not in the WeakMap.

`has(key)`: Returns true if an entry with the specified key exists, otherwise false.

`delete(key)`: Removes the entry with the specified key.

Example:
```javascript
let wm = new WeakMap();
let obj = {};

// Adding an entry
wm.set(obj, 'some value');
console.log(wm.get(obj)); // 'some value'

// Checking for an entry
console.log(wm.has(obj)); // true

// Removing an entry
wm.delete(obj);
console.log(wm.has(obj)); // false
```

### Set
A `Set` is a collection of unique values. It can contain any type of value (primitives or object references) and automatically removes duplicate values.

**Basic Operations:** Creating a Set, Adding Elements, Checking for Existence, Removing Elements, Getting the size, and Clearing all elements

```javascript
const mySet = new Set();

mySet.add(1);
mySet.add(2);
mySet.add(2); // Duplicate values are ignored

console.log(mySet.has(1)); // true

mySet.delete(2);

console.log(mySet.size); // 1

mySet.clear();

```

**Iteration:** You can iterate over the values of a `Set`.

```javascript
const mySet = new Set([1, 2, 3]);

// Iterating over values
for (const value of mySet) {
  console.log(value); // 1, 2, 3
}
```


### WeekSet
A `WeakSet` is a collection of objects, where each object can occur only once in the set. 

Like `WeakMap`, a `WeakSet` holds weak references to its objects, allowing for garbage collection when there are no other references to an object.

**Characteristics**<br>

Only objects as values: Primitive data types cannot be added to a `WeakSet`.

No size property: `WeakSet` does not have a `size` property or any method to get the number of elements.

No iterations: You cannot iterate over the elements of a `WeakSet` `(no `keys()`, `values()`, `entries()`, or `forEach()` methods)`.

Garbage collection: If an object is no longer reachable from the program, it can be garbage collected, and its entry in the `WeakSet` will be removed.

**Methods**<br>

`add(value)`: Adds a new object to the `WeakSet`.

`has(value)`: Returns true if the object is in the `WeakSet`, otherwise `false`.

`delete(value)`: Removes the specified object from the `WeakSet`.

Example
```javascript
let ws = new WeakSet();
let obj = {};

// Adding an object
ws.add(obj);
console.log(ws.has(obj)); // true

// Removing an object
ws.delete(obj);
console.log(ws.has(obj)); // false
```

### Difference between Map and Set

|                     |     Map                 |          Set         |
|---------------------|-------------------------|----------------------|
| Data Structure      | Stores key-value pairs  | Stores unique values |
| Key Types           |Keys can be any type (objects, functions, primitive types)| Only stores values, which must be unique.
|Order of Elements  |Maintains the insertion order of key-value pairs|Maintains the insertion order of values
|Methods|set, get, has, delete, clear, keys, values, entries|add, has, delete, clear, keys, values, entries


## Dom Manuipulation APIs
DOM (Document Object Model) manipulation APIs in JavaScript allow developers to interact with and modify the structure, style, and content of web documents. These APIs provide methods to create, remove, change, and traverse elements and their attributes in the DOM.

### 1. Selecting Elements

**`getElementById`**
Select an element by its ID.

```javascript
const element = document.getElementById('myId');
````
**`getElementsByClassName`**
Selects elements by their class name. Returns a live HTMLCollection.

```javascript
const elements = document.getElementsByClassName('myClass');
```
**`getElementsByTagName`**
Selects elements by their tag name. Returns a live HTMLCollection.

```javascript
const elements = document.getElementsByTagName('div');
```
**`querySelector`**
Selects the first element that matches a CSS selector.

```javascript
const element = document.querySelector('.myClass');
```
**`querySelectorAll`**
Selects all elements that match a CSS selector. Returns a static NodeList.

```javascript
const elements = document.querySelectorAll('.myClass');
```

### 2. Modifying Element Content
**`innerHTML`**
Gets or sets the HTML content inside an element.

```javascript
element.innerHTML = '<p>New content</p>';
```
**`textContent`**
Gets or sets the text content inside an element.

```javascript
`element.textContent = 'New text content';
```
### 3. Modifying Element Attributes

**`getAttribute`**
Gets the value of an attribute on the specified element.

```javascript
const value = element.getAttribute('src');
```
**`setAttribute`**
Sets the value of an attribute on the specified element.

```javascript
element.setAttribute('src', 'newImage.jpg');
```
**`removeAttribute`**
Removes an attribute from the specified element.

```javascript
element.removeAttribute('src');
```
### 4. Modifying Element Styles
**`style`**
Directly modifies the CSS styles of an element.

```javascript
element.style.color = 'blue';
element.style.fontSize = '20px';
```
### Adding and Removing Classes
**`classList**
Provides methods to add, remove, and toggle classes.

```javascript
element.classList.add('newClass');
element.classList.remove('oldClass');
element.classList.toggle('active');
```
### 6. Creating and Inserting Elements
**`createElement`**
Creates a new element.

```javascript
const newElement = document.createElement('div');
```
**`appendChild`**
Adds a new child node to the end of a specified parent node.

```javascript
parentElement.appendChild(newElement);
```
**`insertBefore`**
Inserts a new node before a specified existing node.

```javascript
parentElement.insertBefore(newElement, referenceElement);
```
**`removeChild`**
Removes a child node from the DOM.

```javascript
parentElement.removeChild(childElement);
```
**`replaceChild`**
Replaces a child node with a new node.

```javascript
parentElement.replaceChild(newElement, oldElement);
```
### 7. Event Handling
**`addEventListener`**
Attaches an event handler to an element.

```javascript
element.addEventListener('click', function() {
  console.log('Element clicked!');
});
```
**`removeEventListener`**
Removes an event handler from an element.

```javascript
element.removeEventListener('click', eventHandlerFunction);
```
### 8. Traversing the DOM
**`parentNode`**
Gets the parent node of an element.

```javascript
const parent = element.parentNode;
```
**`childNodes**`
Gets a collection of a node's child nodes, including text nodes and comments.

```javascript
const children = element.childNodes;
```
**`firstChild` and `lastChild**
Gets the first and last child nodes of an element.

```javascript
const first = element.firstChild;
const last = element.lastChild;
```
**`nextSibling` and `previousSibling`**
Gets the next and previous sibling nodes of an element.

```javascript
const next = element.nextSibling;
const previous = element.previousSibling;
```
**`children`**
Gets a live HTMLCollection of the element's child elements (excluding text and comment nodes).

```javascript
const children = element.children;
```
**`firstElementChild` and `lastElementChild`**
Gets the first and last child elements.

```javascript
const first = element.firstElementChild;
const last = element.lastElementChild;
```
**`nextElementSibling` and `previousElementSibling`**
Gets the next and previous sibling elements.

```javascript
const next = element.nextElementSibling;
const previous = element.previousElementSibling;
```

## Web storage in JS
Since HTML5 was introduced, we have had a variety of methods for caching or storing data on the client browser.<br>

Web storage - Although it operates on similar concepts to server-side storage, browser storage or client-side storage has various use cases. It is made up of JavaScript APIs that enable us to store data on the client (i.e., on the user's computer), where it may later be retrieved as needed.<br>

**Cookies, local storage, and session storage are the three methods most frequently used to save data locally on browsers.** 

Javascript could access web storage, and the server couldn't read any of this information unless it was manually included in the request.

HTML web storage offers two objects for data storage on the client:

* Data is stored in local storage objects that have no expiration dates.
* Data is stored for one session in a session storage object (data is lost when the browser tab is closed).

### Local Storage
We can store data as key/value pairs in a web browser using the local storage web storage technique on the client's computer. 

Unless the user explicitly deletes it from the browser, the data is kept in local storage forever

There are four ways to set, retrieve, remove, and clear data from local storage:

* To set the data in local storage, use the setItem() method. The parameters for this method are key and value. With this method, we can store value with a key. localStorage.setItem(key, value);
* We can use the getItem() method to access the data kept in local storage. The key whose value we need to retrieve is the sole parameter for this procedure. localStorage.getItem(key);
* The removeItem() method, which is kept in memory with the key, allows us to delete the data. localStorage.removeItem(key);
* All of the data kept in the local storage can be cleared using the clear() method.

Depending on our use case, there are advantages and disadvantages to using local storage

**Advantages**
* There is no expiration date for the data kept in local storage.
* The storage limitation is approximately 10MB.
* Data from local storage is never sent to the server.
  
**Disadvantages**
* Since local storage data is in plain text, it is not designed to be secure.
* Since the data type is restricted to strings, serialization is required.
* Only the client side, not the server side, is capable of reading data.

### Session Storage
The localStorage and the sessionStorage are extremely similar. However, the primary distinction is in how long information stays in the browserâ€”until the current tab or session is active. 

The data stored in session storage is also deleted when you close the tab or end the session. 

Using the setItem() and getItem() methods, we can also set and get session data, just like we do with local storage.

### Cookie
Cookies assist us in storing client-side data to provide website visitors with a customized experience. Cookies are transmitted to the server along with requests and returned to the client in response; as a result, the server and client exchange cookie data with each request. 

The servers could deliver user-tailored content using the cookie data.

**To mitigate a few security vulnerabilities like cross-site scripting, we have an HTTPOnly cookie flag that may be used to limit cookie access in JavaScript (the cookies are only available for servers to access).**

Session Cookies - Session cookies are deleted when the browser is closed because they do not contain attributes such as Expires or Max-Age.

Session Cookies - Session cookies are deleted when the browser is closed because they do not contain attributes such as Expires or Max-Age.

![image](https://github.com/kaleeswariP/javascript-guide/assets/22699303/930dc92e-07f6-4e86-a02c-3c957e5fb8c7)

# Advanced Topics

* [Event Loop, Microtasks, Macrotasks](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#event-loop-microtasks-macrotasks)
* [Events: DOMContentLoaded, load, beforeunload, unload](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#events-domcontentloaded-load-beforeunload-unload)
* [Polyfilles](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#polyfills)
* [Memoization](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#memoization)
* [Generator Functions](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#generator-functions)
* [Web APIs](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#web-apis)
* [Design Patterns](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#design-patterns)

## Event Loop, Microtasks, Macrotasks

## Events: DOMContentLoaded, load, beforeunload, unload 

## Polyfills
(Mostly asked polyfills: `Promise`, `Promise.all`, `Promise.any`, `Promise.race`, `Promise.allSettled`, `call`, `apply`, `bind`, `map`, `reduce`, `filter`, `forEach`, `flat`, `fetch API`)
## Memoization

## Generator Functions

## Web APIs

## Design Patterns

**Creational Patterns**
* Singleton
* Factory Method
* Abstract Factory
* Builder
* Prototype
* Provider
* Prototype
* Observer
* Module
* HOC

**Structural Patterns**
* Adapter
* Decorator
* Facade
* Proxy
  
##  Working of JS Engine 

# Coding concepts

 * [Currying](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#1-currying)
 * [Closures](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#2-closures)
    * [Factory functions](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#factory-functions)
    * [Dynamic function generation](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#dynamic-function-generation)
 * [IIFE](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#3-iife)
 * [Destructuring](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#4-destructuring)
 * [Inheritance](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#5-inheritance)
   * [Prototype inheritance](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#5-inheritance)
   * [Class inheritance](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#class-inheritance)
 * [Spread and Rest operator](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#6-spread-and-rest-operator)
 * [Callback, Promises, and Async Await](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#7-callback-promises-and-async-await)
 * [Debouncing and Throttling](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#8-debouncing-and-throttling)
 * [Event Propagation, Event Bubbling, Capturing, and Delegation](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#9-event-propagation-event-bubbling-capturing-and-delegation)
 * [setTimeout, setInterval](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#10-settimeout-setinterval)
 * [High Order Functions](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#11-high-order-functions)
     * [First order functions]()
     * [Pure functions]()
 * [Call, Apply, Bind](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#12-call-apply-bind)
 * [Hoisting and Temporal dead zone](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#13-hoisting-and-temporal-dead-zone)
 * [Call by value and call by the difference](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#14-call-by-value-and-call-by-the-difference)
 * [Execution Context](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#15-execution-context)
 * [Callstack](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#16-callstack)
 * [How asynchronous functions work inside loops](https://github.com/kaleeswariP/javascript-programming-language?tab=readme-ov-file#2-swap-the-two-variables-values-without-using-the-temporary-variable)
 * 
## 1. Currying
### Definition:
Currying is a fundamental concept in JavaScript that involves transforming a function with multiple arguments into a series of functions, each taking a single argument.
This makes the code more flexible and reusable.
### Syntax:
* It creates a chain of functions, each taking a single argument and returning a new function that waits for the next argument
* This chaining continues until all the arguments are provided, and the final function produces the desired result.
### Challenge 1: Currency converter
```javascript
const convertCurrency = (conversionRate) => (fromCurrency) => (toCurrency) => (amount) => {
const convertedAmount = ( amount * conversionRate[fromCurrency][toCurrency]).toFixed(2);

return `${amount} ${fromCurrency} is equal to ${convertedAmount} ${toCurrency}`;
}

const usdToEur = convertCurrency({USD: { EUR: 0.85}});
console.log(usdToEur("USD")("EUR")(100));

```
### Challenge 2: customer permissions
```javascript
const checkPermission = permissions => resource => action => {
    if(permissions[resource] && permissions[resource].includes(action)){
        return `Permission granted: ${action} in ${resource}`;
    }
    
    return `Permission denied: ${action} in ${resource}`;
}

const userPermissions = checkPermission({files: ['read','write'], photos:['read']});

console.log(userPermissions("files")("read"));
```
### Challenge 3: Functional composition

```javascript
const pipe = (...fns) => (x) => fns.reduce((acc, fn) => fn(acc),x);

const square = x => x * x;

const double = x => x * 2;

const addOne = x => x + 1;

const transform = pipe(square, double, addOne);

console.log(transform(3));
// result: 19 (square(3) => double(9) => addOne(18))
```
## Currying vs Partial function
While both currying and partial functions involve breaking down functions, currying generates a chain of functions that each take one argument,<br> whereas partial functions fix some arguments and return a new function with fewer arguments.
Here is a comparison:
**Currying**
```javascript
const multiply = a => b => a * b;

const double = multiply(2);
console.log(double(5));
```
**Partial function**
This technique is often used for functional programming and can be implemented in various ways in JavaScript, such as using closures or bind() method.
```javascript
const partialMultiply = (a, b) => a* b;
const double = x => partialMultiply(2,x);

console.log(double(5));
```
*Factory functions are used to create and return instances of objects.*
*Partial functions are functions created by fixing some arguments of another function, producing a new function with reduced arity (number of arguments).*

## 2. Closures
### Definition:
A closure is a function that is bundled together with its lexical environment.ie., It is a function that remembers the scope in which it was created, even if it is executed outside of the scope.
### Syntax:
```javascript
function outerClosureFunction (input) {
    let message ='count';
    const = count = 10;
    
    function inner() {
        return message + count;
    }
    
    return inner;
}

let closureObj = new outerClosureFunction(3);
console.log(closureObj());
```
**Usecases**
### Data encapsulation
You can create private variables that can't be accessed from outside.
```javascript
function Counter(){
let count=0;
return {
increment: function(){count++;},
getCount: function(){ return count;}
};
}
```
### Factory functions:
A factory function is a function that returns an object. It is called a "factory" because it's designed to produce instances of objects, similar to how a factory produces goods.
Sometimes factory functions return other functions, often with some arguments or internal variables set to specific values(closures). 
They are a way to generate functions dynamically but not all dynamic function generation is done through factory functions.

```javascript
function multiplier(factor){
return x=> x*factor;
}

//example2
function createPerson(name, age) {
  return {
    name: name,
    age: age,
    greet: function() {
      console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);
    }
  };
}

let person1 = createPerson('Alice', 30);
let person2 = createPerson('Bob', 25);
```
### Dynamic function generation
Dynamic function generation refers to the creation of functions at runtime based on certain conditions or parameters. This often involves closures because the dynamically generated functions might close over variables in their surrounding scope.
### function curation:
Function curation is the process of taking a function with multiple arguments and producing from it a function that takes fewer arguments. The missing arguments are set to specific values. This is closely related to the concept of "partial application" in functional programming.


## 3. IIFE
An IIFE (Immediately Invoked Function Expression) is a JavaScript function that is executed right after it is defined.

It is used to create a local scope for variables and functions, preventing them from polluting the global namespace.

This is particularly useful for encapsulating code, creating private variables and methods, and implementing the module pattern. IIFEs can accept parameters, return values, and help in organizing and structuring code in a clean and modular way.

Example:

```javascript
(function() {
  // code here
})();
```

**Encapsulation:** IIFEs help in creating a local scope for variables and functions, thus preventing them from polluting the global namespace.

**Avoid Global Namespace Pollution:** By using IIFEs, you can avoid defining too many global variables and functions.

**Private Variables and Methods:** IIFEs can be used to create private variables and methods.

```javascript
var counter = (function() {
  var count = 0; // private variable

  return {
    increment: function() {
      count += 1;
      return count;
    },
    reset: function() {
      count = 0;
      return count;
    }
  };
})();

console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
console.log(counter.reset()); // 0
```

**Module Pattern:** IIFEs are often used in the module pattern to create modules with private and public methods.

```javascript
var myModule = (function() {
  var privateVar = "I am private";

  function privateMethod() {
    console.log(privateVar);
  }

  return {
    publicMethod: function() {
      privateMethod();
    }
  };
})();

myModule.publicMethod(); // I am private
```

## 4. Destructuring
Destructuring is a feature in JavaScript that allows you to extract values from arrays or properties from objects and assign them to variables in a more concise and readable way. 

### Destructuring Arrays
Array destructuring allows you to unpack values from arrays into distinct variables.

Basic Syntax
```javascript
const [a, b] = [1, 2];
console.log(a); // 1
console.log(b); // 2
```
**Skipping Items**

You can skip items in the array by leaving an empty space.

```javascript
const [a, , b] = [1, 2, 3];
console.log(a); // 1
console.log(b); // 3
```

**Default Values**

You can provide default values in case the array does not have enough elements.

```javascript
const [a, b = 5] = [1];
console.log(a); // 1
console.log(b); // 5
```

**Using Rest Operator**

You can use the rest operator `(...)` to collect the remaining elements into a new array.

```javascript
const [a, ...rest] = [1, 2, 3, 4];
console.log(a); // 1
console.log(rest); // [2, 3, 4]
```

### Destructuring Objects
Object destructuring allows you to unpack properties from objects into distinct variables.

Basic Syntax
```javascript
const { name, age } = { name: 'John', age: 30 };
console.log(name); // John
console.log(age); // 30
```

**Renaming Variables**

You can rename variables while destructuring by using a colon `(:)`.

```javascript
const { name: fullName, age: years } = { name: 'John', age: 30 };
console.log(fullName); // John
console.log(years); // 30
```

**Default Values**

You can provide default values if the property does not exist in the object.

```javascript
const { name, age = 25 } = { name: 'John' };
console.log(name); // John
console.log(age); // 25
```

**Nested Destructuring**

You can destructure nested objects.

```javascript
const person = { name: 'John', address: { city: 'New York', zip: 10001 } };
const { name, address: { city, zip } } = person;
console.log(name); // John
console.log(city); // New York
console.log(zip); // 10001
```

**Using Rest Operator**

You can use the rest operator to collect the remaining properties into a new object.

```javascript
const { name, ...rest } = { name: 'John', age: 30, city: 'New York' };
console.log(name); // John
console.log(rest); // { age: 30, city: 'New York' }
```

### Destructuring Function Parameters
You can destructure arrays and objects directly in function parameters.

**Array Destructuring in Function Parameters**

```javascript
function sum([a, b]) {
  return a + b;
}
console.log(sum([1, 2])); // 3
```

**Object Destructuring in Function Parameters**

```javascript
function greet({ name, age }) {
  return `Hello, my name is ${name} and I am ${age} years old.`;
}
console.log(greet({ name: 'John', age: 30 })); // Hello, my name is John and I am 30 years old.
```

## 5. Inheritance

### Protype inheritance
_proto_ is a property of every variable that points to the parent object inherited from. In contrast, the prototype is a property of every constructor function that contains all stuff that its instance will inherit. So both are the same thing but act from different ends.

The difference between class inheritance and prototypal inheritance is that if any changes to class methods occur after creating some objects then those objects do not get the updated methods as their old/already created instances do not get updated because when we develop functions using this in the constructor are considered as properties, not as methods 
But, in prototypal inheritance, it will get updated to all the existing instances.

There are three ways to create prototype inheritance in js

Code sample - https://github.com/ColorCode/js-10-things/blob/main/1-inheritance/example.js

### Class inheritance

Class inheritance in JavaScript is a mechanism that allows one class to inherit properties and methods from another class.

Inheritance enables the creation of new classes based on existing classes, where the new class `(subclass or derived class)` inherits the properties and methods of the existing class `(superclass or base class)`.

JavaScript uses the `extends` keyword to establish an inheritance relationship between two classes, and the `super` keyword to call the constructor and methods of the superclass

```javascript
// Superclass
class Animal {
  constructor(name) {
    this.name = name;
  }

  speak() {
    console.log(`${this.name} makes a noise.`);
  }
}

// Subclass
class Dog extends Animal {
  constructor(name, breed) {
    super(name); // Call the superclass constructor
    this.breed = breed;
  }

  speak() {
    console.log(`${this.name} barks.`);
  }

  getBreed() {
    console.log(`${this.name} is a ${this.breed}.`);
  }
}

const myDog = new Dog('Rex', 'German Shepherd');
myDog.speak();  // Rex barks.
myDog.getBreed(); // Rex is a German Shepherd.

```

**Superclass**

A superclass `(or base class)` is a class that is being inherited by another class. In the example above, `Animal` is the superclass. It contains a constructor to initialize the name property and a method speak().


**Subclass**

A subclass `(or derived class)` is a class that inherits from another class. In the example above, the `Dog` is the subclass inherited from the `Animal`. It uses the `extends` keyword to establish the inheritance.

**The `super` Keyword**

The `super` keyword is used within a subclass to call the constructor and methods of its superclass. This is necessary to initialize the inherited properties and allows the subclass to build upon the functionality of the superclass.

**Overriding Methods**

Subclasses can override methods from the superclass to provide specific implementations. In the example, the `speak()` method in `Dog` overrides the `speak()` method in `Animal`.


## 6. Spread and rest operator
The spread and rest operators in JavaScript are both represented by three consecutive dots `(`...`)`. 

### Spread Operator
The spread operator is used to expand elements of an iterable (like an array or a string) into individual elements.

#### Use Cases

1. Arrays: Copying Arrays, Merging Arrays, and adding elements to the array.
   
```javascript
const arr1 = [1, 2, 3];
const arr2 = [...arr1];
console.log(arr2); // [1, 2, 3]

const merged = [...arr1, ...arr2];
console.log(merged); // [1, 2, 3, 4, 5, 6]

const newArr = [0, ...arr, 4];
console.log(newArr); // [0, 1, 2, 3, 4]
```

2. Objects: Copying Objects, Merging Objects, Adding Properties to an Object

```javascript
const obj1 = { a: 1, b: 2 };
const obj2 = { ...obj1 };
console.log(obj2); // { a: 1, b: 2 }

const mergedObj = { ...obj1, ...obj2 };
console.log(mergedObj); // { a: 1, b: 2, c: 3, d: 4 }

const newObj = { ...obj, c: 3 };
console.log(newObj); // { a: 1, b: 2, c: 3 }

```

3. Function Calls: The spread operator can be used to pass an array as arguments to a function.

```javascript
function sum(x, y, z) {
  return x + y + z;
}
const numbers = [1, 2, 3];
console.log(sum(...numbers)); // 6

```

### Rest Operator

The rest operator is used to gather a variable number of arguments into an array. It is primarily used in function parameter lists to handle an indefinite number of arguments.

#### Use cases

1. Function Parameters: Gathering Remaining Arguments, Combining with Named Parameters.

```javascript
function sum(...args) {
  return args.reduce((acc, val) => acc + val, 0);
}
console.log(sum(1, 2, 3, 4)); // 10

function myFunction(a, b, ...rest) {
  console.log(a); // 1
  console.log(b); // 2
  console.log(rest); // [3, 4, 5]
}
myFunction(1, 2, 3, 4, 5);

```
  
2. Array Destructuring: The rest operator can be used to collect the remaining elements of an array.

```javascript
const [a, b, ...rest] = [1, 2, 3, 4, 5];
console.log(a); // 1
console.log(b); // 2
console.log(rest); // [3, 4, 5]
```

3. Object Destructuring: The rest operator can also be used in object destructuring to collect remaining properties.

```javascript
const { a, b, ...rest } = { a: 1, b: 2, c: 3, d: 4 };
console.log(a); // 1
console.log(b); // 2
console.log(rest); // { c: 3, d: 4 }

```



## 7. Callback, Promises, and Async Await

### Promises
**syntax**
```javascript
let promise = new Promise(function(resolve, reject) {
  if(success)
      resolve("done!"), 1000);
      else reject("Not valid");
});

// resolve runs the first function in .then
promise.then(
  result => alert(result), // shows "done!" after 1 second
  error => alert(error) // doesn't run
);
// If weâ€™re interested only in errors, then we can use null as the first argument: .then(null, errorHandlingFunction). Or we can use .catch(errorHandlingFunction), which is exactly the same.
promise.catch(alert); // shows "Error: Whoops!" after 1 second

```
**convert the above promise to Async and await**
```javascript
const returnSamplePromise = () => {
return promise;
}

async function convert() {
    let res = await returnSamplePromise();
}

convert();

```
## 8. Debouncing and Throttling 
### Debouncing
Debouncing ensures that a function is only called after a certain period has passed since it was last called. 

If the event is triggered again within that period, the timer is reset.

**Example use case:** A search input field where the search function should only be called after the user has stopped typing for a specified period.

### Throttling
Throttling ensures that a function is called at most once in a specified period. 

Unlike debouncing, throttling ensures that the function is executed at regular intervals, regardless of how many times the event is triggered.

**Example use case:** Handling window resize events where the resize handler should only be called once every 100 milliseconds.


## 9. Event Propagation, Event Bubbling, Capturing, and Delegation

*In JavaScript, <br>
event propagation refers to the way events travel through the Document Object Model (DOM) hierarchy. <br>
This process involves two main phases: capturing and bubbling. <br>
Event delegation is a technique that leverages these phases to handle events more efficiently.<br>* 

### Event Propagation
Event propagation describes the order in which events are handled in the DOM.

1. Capturing Phase (Capture Phase):

The event starts at the root of the DOM tree and travels down to the target element.
During this phase, event listeners set for capturing can handle the event.

2. Target Phase:

The event reaches the target element, where it originated.
Event listeners on the target element can handle the event.

3. Bubbling Phase:

After reaching the target, the event travels back up the DOM tree to the root.
During this phase, event listeners set for bubbling can handle the event.

### Event bubbling
Event bubbling refers to the process of the event traveling from the target element up through its ancestors. It allows higher-level elements to react to events fired on their descendants.
```javascript
document.getElementById('child').addEventListener('click', () => {
  console.log('Child clicked');
});

document.getElementById('parent').addEventListener('click', () => {
  console.log('Parent clicked');
});

```
### Event Capturing
Event capturing is the opposite of event bubbling. The event travels from the root to the target element. To handle an event during the capturing phase, you need to set the `useCapture` parameter to `true` when adding the event listener.

```javascript
document.getElementById('child').addEventListener('click', () => {
  console.log('Child clicked');
}, true);

document.getElementById('parent').addEventListener('click', () => {
  console.log('Parent clicked');
}, true);

// If you click on the child element, 'Parent clicked' will be logged before 'Child clicked', because the event is captured first by the parent.

```

### Event Delegation

Event delegation is a technique that involves using a single event listener to manage all events of a particular type for multiple child elements. 

This is particularly useful for managing events in a dynamic list of items, as it avoids the need to attach individual event listeners to each item.

By leveraging event bubbling, you can place a single event listener on a common ancestor and handle events for all its descendants.

```javascript
document.getElementById('parent').addEventListener('click', (event) => {
  if (event.target && event.target.matches('li')) {
    console.log('List item clicked:', event.target);
  }
});

//Here, a single-click event listener is added to the parent element. When any li element inside the parent is clicked, the event bubbles up to the parent, where it is handled.

```

## 10. setTimeout, setInterval 
setTimeout and setInterval are two essential functions in JavaScript for working with timers. They allow you to execute code after a delay `(setTimeout)` or repeatedly at specified intervals `(setInterval)`. 

**`setTimeout`**

The `setTimeout` function executes a specified function once after a given delay (in milliseconds).
```javascript
let timeoutID = setTimeout(function, delay, arg1, arg2, ...);

//example
function sayHello() {
  console.log('Hello, World!');
}

// Execute sayHello after 2 seconds (2000 milliseconds)
let timeoutID = setTimeout(sayHello, 2000);

// If needed, clear the timeout before it executes
clearTimeout(timeoutID);

```

**`setInterval`**

The `setInterval` function repeatedly executes a specified function at fixed intervals (in milliseconds).

```javascript
let intervalID = setInterval(function, delay, arg1, arg2, ...);

//example
function sayHello() {
  console.log('Hello, World!');
}

// Execute sayHello every 2 seconds (2000 milliseconds)
let intervalID = setInterval(sayHello, 2000);

// If needed, clear the interval to stop the repeated execution
clearInterval(intervalID);

```

setTimeout: Use clearTimeout(timeoutID) to prevent the function from being executed.
`setInterval`: Use `clearInterval(intervalID)` to stop the repeated execution.

## 11. High Order Functions 
## 12. Call, Apply, Bind 
## 13. Hoisting and Temporal dead zone
### Hiosting
Hoisting is a JavaScript mechanism where variables, function declarations, and classes are moved to the top of their containing scope during the compile phase. This means that you can use variables and functions before you declare them in your code.

With `var`, the declaration is hoisted but not the initialization. The variable is set to undefined until the line of code where it is initialized.

With `let` and `const`, the declarations are hoisted, but they are not initialized. Accessing them before the declaration results in a ReferenceError.

Function declarations are fully hoisted, meaning both the function name and the function body are hoisted.

Function expressions and arrow functions are not hoisted.

### Temporal Dead zone

The Temporal Dead Zone (TDZ) refers to the period between the entering of a scope `(like a block or function)` and the point at which a variable declared with `let` or `const` is initialized. During this period, accessing the variable will result in a `ReferenceError`.


## 14. Call by value and call by the difference
## 15. Execution Context
## 16. Callstack
## 17. How asynchronous functions work inside the loop

1. Using `for...of` with `await`.
2. Using `Promise.all` for parallel execution: If the order of execution is not important and you want to run async calls in parallel.
3. Using `forEach` with async functions: `forEach` does not work well with `async/await` because it does not wait for the completion of the async operations. However, you can use it if you handle the promises appropriately.
4. Using reduce to handle async calls sequentially.
5. Using traditional for loop with await

Example:

```javascript
const asyncFunction = async (item) => {
  // Your async code here
};

const processArray = async (array) => {
  await array.reduce(async (promise, item) => {
    await promise;
    await asyncFunction(item);
  }, Promise.resolve());
};

processArray([1, 2, 3, 4, 5]);

```



# Coding challenges
## 1. What is the output of the snippet below

The JavaScript for-in statement loops through the properties of an Object:

```javascript
let language = [ 'python', 'javascript'];
let obj = {...language};

console.log('2' in language);
console.log('javascript' in obj);
```
## 2. Swap the two variables' values without using the temporary variable

```javascript
let x = 2, y = 3;
    console.log("Before Swapping: x = " +  x + ", y = " + y);
    // x now becomes 5
    x = x + y;
    // y becomes 2
    y = x - y;
    // x becomes 5
    x = x - y;
    console.log("After Swapping: x = " + x + ", y = " + y);
//using Array
[x,y] = [y,x]
```

## 3. Write a function to count the occurrences of each character in the string. 

```javascript
function countCharacterOccurrences(str) { 
  const charCount = {}; 
  for (let char of str) { 
    charCount[char] = (charCount[char] || 0) + 1; 
  } 
  return charCount; 
} 
```

## 4. Get the output format of the given input string 
let input = 'apple' the output should be `"A-Pp-Ppp-Llll-Eeeee"`

```javascript
const sample = (input) => {
    let spl = input.split('');
    
    let res = spl.reduce((acc, val, index) => {
        for(let i=0; i<=index;i++){
            if(i==0)
                acc = acc + val.toUpperCase();
            else acc = acc + val;
        }
        return index==spl.length-1 ? acc : acc+ '-';
    },'');
    
    return res;
}

console.log(sample(str));
```
## 5. Remove duplicates from the array or get the unique values in an array
```javascript
const removeDuplicates = arr => [...new Set(arr)];

console.log(removeDuplicates([1,2,3,22,3,2,4,5,5,5,6,7]));
```
**without using built-in function(set)**
```javascript
const removeDuplicates = arr => {
    let result = [];
    arr.map((val) => {
        if(!result.includes(val)){
            result.push(val);
        };
    });
    
    return result;
}

console.log(removeDuplicates([1,2,3,22,3,2,4,5,5,5,6,7]));
```

## 6. String Related tasks

### Check if a string is a palindrome
A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward 
```javascript
const isPalindrome = str => str === str.split('').reverse().join('');

console.log(isPalindrome('racecar'));
```
### Remove all the vowels from a string
```javascript
const removeVowels = str => str.replace(/[aeiou]/gi, '');
console.log(removeVowels('hello world'));
```
### Check if a string contains a substring
```javascript
const contains = (str, subString) => str.includes(subString);
console.log(contains('hello world', 'll'));
```
###  Write a JavaScript program to convert a string to a title case (capitalize the first letter of each word). 

```javascript
function titleCase(str) {
    return str.toLowerCase().split(' ').map(function (word) {
        return (word.charAt(0).toUpperCase() + word.slice(1));
    }).join(' ');
}
console.log(titleCase("converting string to titlecase"));
```
### Write a function that determines if two strings are anagrams of each other.
An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

```javascript
function areAnagrams(str1, str2) { 
  return str1.split("").sort().join("") === str2.split("").sort().join(""); 
} 
```
### Implement a function to reverse a string without using the built-in reverse() method.
```javascript
function reverseString(str) { 
  let reversed = "; 
  for (let i = str.length - 1; i >= 0; i--) { 
    reversed += str[i]; 
  } 
  return reversed; 
} 
```


## 6. Array Related tasks
### Sorting an array
```javascript
const sortAsc = arr => array.sort((a,b) => a -b);
const sortDesc = arr => array.sort((a,b) => b-a);
```
### Get the first n elements of the array
```javascript
const take = (arr,n) => arr.slice(0,n);
console.log(take([1,2,3,4,5,6],3));
```
### Get the last n elements of the array
```javascript
const take = (arr,n) => arr.slice(-n);
console.log(take([1,2,3,4,5,6],3));
```
### Check if an array is empty
```javascript
const isArrayEmpty = arr => Array.isArray(arr) && arr.length > 0;
console.log(isArrayEmpty([1,2,3,4,5,6]));
```
### Find max/min values in an array
```javascript
Math.max(...array);
Math.min(...array);
```
### Implement a function to find the sum of all the numbers in an array. 
Using reduce() method.
```javascript
function findSum(arr) { 
  return arr.reduce((sum, num) => sum + num, 0); 
} 
```




## 7. Find the domain name from an email
```javascript
const extractDomain = mail => mail.split('@')[1];

console.log(extractDomain('kaleewaripss96@gmail.com'));
```
## 8. Flatten a nested array

The flat() method is a built-in JavaScript method that flattens the input array into a new array. This method takes an optional depth parameter, which defines the depth level specifying how deep a nested array structure should be flattened.

```javascript
// using flat() method

let nestedArray = [1, [2, 3], [4, [5, 6]], 7];
let flatArray = nestedArray.flat(2);
console.log(flatArray); // [1, 2, 3, 4, 5, 6, 7];

// using recursion

function flattenArray(array) {
  return array.reduce((accumulator, value) => 
    Array.isArray(value)? accumulator.concat(flattenArray(value)) : accumulator.concat(value), []);
}
let nestedArray = [1, [2, 3], [4, [5, 6]], 7];
let flatArray = flattenArray(nestedArray);

console.log(flatArray); // [1, 2, 3, 4, 5, 6, 7]
```

## 9. Please find the key value in the nested object, if exists return its values else return undefined

```javascript
const obj ={
  foo: { bar: { biz: 'hello', a: 10 }, w: 1000 },
  sap: {},
  ss: 'welcome'
}

const deepGet = (obj, key = 'foo.bar.biz') => {
    let input = key.split('.');
    let output = input.reduce((acc, val, index) => {
      return acc?.[val] ?? null;
    },obj);
    
    return output;
};

console.log(deepGet(obj));
deepGet(data, ['foo', 'foz', 2]); // 3
deepGet(data, ['foo', 'bar', 'baz', 8, 'foz']); // null
```

## 10. Write a javascript program to calculate the factorial of a given number.

A factorial number is the product of all positive integers equal to or less than the given number.  

The multiplication of all positive integers say â€œnâ€, that will be smaller than or equivalent to n is known as the factorial.

```javascript
function factorial(number) { 
  if (number === 0 || number === 1) { 
    return 1; 
  } else { 
    return number * factorial(number - 1); 
  } 
} 
// OR
function factorial(num) { 
  if (num <= 1) return 1; 
  return num * factorial(num - 1); 
} 
```

## 11. Write a JavaScript function to check if a given number is prime.
To check if a given number is prime, loop from 2 to the square root of the number. If any integer evenly divides it, the number is not prime. 

```javascript
function isPrime(num) { 
  if (num <= 1) return false; 
  for (let i = 2; i <= Math.sqrt(num); i++) { 
    if (num % i === 0) return false; 
  } 
  return true; 
} 
```
## 12. Find the brackets that match the string in javascript. if the input string is â€œad(dfd[0]) {d}â€ then the output should be 1 and count of brackets and if the input string is â€œad(dfd[0) {dâ€ then the output should be 0.

[Hint for the solution](https://medium.com/analytics-vidhya/javascript-check-valid-parentheses-with-a-stack-bc7b1bab26c2#:~:text=Loop%20through%20each%20element%20in,keep%20iterating%20through%20the%20string)

## 13. Write a program to print all the LEADERS in the array. An element is a leader if it is greater than all the elements to its right side. And the rightmost element is always a leader. 

For example:

Input: arr[] = {16, 17, 4, 3, 5, 2}, 
Output: 17, 5, 2


# Real-time coding snippets for the project
## 1. Generate random string
We can use `Math.random()` to generate a random string, It is very convenient to generate a unique ID

```javascript
const randomString = () => Math.random().toString(36).slice(2);
```
## 2. Generate a random string of a given length

```javascript
const randomString = (length =10) => {
    let result = '';
    while(result.length < length) {
        result += Math.random().toString(36).slice(2);
    }
    
    return result.slice(0, length);
}
```
Random number of a given length
```javascript
 const generateRandomNumbers = () => {
    let random = [];
    for (let i = 0; i < count; i++) {
      random.push(Math.floor(Math.random() * 10));
    }
    setRandom(random);
  }; 
```
## 2. Copy content to the clipboard

```javascript
const copyToClipboard = text => navigator.clipboard.writeText(text);
copyToClipboard("Hello world");
```

## 3. Clear all cookies
```javascript
const clear = document.cookie.split(';').forEach(cookie => document.cookie = cookie.replace(/^ +/, '').replace(/=.*/, `=;expires=${new Date(0).toUTCString()};path=/`));
```
## 4. Get the selected text by the user
```javascript
const getSelectedText = () => window.getSelection().toString();
getSelectedText();
```
## 5. Scroll to the top of the page
```javascript
const goToTop = () => window.scrollTo(0,0);
goToTop();
```
## 6. Check whether the user has scrolled to the bottom of a page
```javascript
const scrolledToBottom = () => document.documentElement.clientHeight + window.scrollY >= document.documentElement.scrollHeight;
```
## 7. Find out if the current tab is active
```javascript
const isTabInView = () => !document.hidden
```
## 8. Redirect the user to a URL
```javascript
const redirect = url => location.href = url;

redirect("https://www.google.com/");
```
## 9. Open the browser print box
```javascript
const showPrintDialog = () => window.print();
```
## 10. Generate a random boolean value
```javascript
const randomBoolean = () => Math.random() >=0.5;

randomBoolean();
```
## 11. Generate a random number between two values
```javascript
// Returns a random number between the min and max variable's values
const randomNumber = Math.random() * (max - min) + min;
```
## 12. Check the given number is an integer
```javascript
const isInteger = (num) => num % 1 === 0;
```
## 13. Check if a variable is an array
```javascript
const isArray = arr => Array.isArray(arr);
```
## 14. Date related tasks
**Check if the date is the weekend**
`getDay()` will return the day of the week (from 0 to 6) of a date.
```javascript
const isWeekend = date => {
    console.log(date.getDay());
    return [0, 6].indexOf(date.getDay()) !== -1;
}
console.log(isWeekend(new Date('2024-06-22'))); // sat
console.log(isWeekend(new Date('2024-06-23'))); // sun
```
**getting day of the week**
```javascript
function getDayName(dayIndex) {
  const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
  return days[dayIndex];
}
// Create a Date object for February 26, 2024 (a Tuesday)
const today = new Date('2024-02-26');
// Using getDay() to retrieve the day of the week
const dayOfWeek = today.getDay();

console.log(`Today is a ${getDayName(dayOfWeek)}.`);
```
**Calculate the number of days between two dates**
```javascript
const dayDiff = (date, date2) => Math.ceil(Math.abs(date - date2) / 84600000);

console.log(dayDiff(new Date('2023-05-19'), new Date('2024-05-19')));
```
## 15. Capitalize a string
```javascript
const capitialise = str => str.charAt(0).toUpperCase() + str.slice(1);

console.log(capitialise('hello world'));
```
## 11. Write a JavaScript function that takes an array of numbers and returns a new array with only the even numbers.
```javascript
function filterEvenNumbers(numbers) { 
  return numbers.filter(num => num % 2 === 0); 
}
```

## 11. Generate a random number between two values
```javascript
// Returns a random number between the min and max variable's values
const randomNumber = Math.random() * (max - min) + min;
```## 11. Generate a random number between two values
```javascript
// Returns a random number between the min and max variable's values
const randomNumber = Math.random() * (max - min) + min;
```## 11. Generate a random number between two values
```javascript
// Returns a random number between the min and max variable's values
const randomNumber = Math.random() * (max - min) + min;
```## 11. Generate a random number between two values
```javascript
// Returns a random number between the min and max variable's values
const randomNumber = Math.random() * (max - min) + min;
```## 11. Generate a random number between two values
```javascript
// Returns a random number between the min and max variable's values
const randomNumber = Math.random() * (max - min) + min;
```## 11. Generate a random number between two values
```javascript
// Returns a random number between the min and max variable's values
const randomNumber = Math.random() * (max - min) + min;
```## 11. Generate a random number between two values
```javascript
// Returns a random number between the min and max variable's values
const randomNumber = Math.random() * (max - min) + min;
```## 11. Generate a random number between two values
```javascript
// Returns a random number between the min and max variable's values
const randomNumber = Math.random() * (max - min) + min;
```## 11. Generate a random number between two values
```javascript
// Returns a random number between the min and max variable's values
const randomNumber = Math.random() * (max - min) + min;
```## 11. Generate a random number between two values
```javascript
// Returns a random number between the min and max variable's values
const randomNumber = Math.random() * (max - min) + min;
```## 11. Generate a random number between two values
```javascript
// Returns a random number between the min and max variable's values
const randomNumber = Math.random() * (max - min) + min;
```

